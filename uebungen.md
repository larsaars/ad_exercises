# Reihenfolge der Uebungsblaetter / Themen

1. WDH von altem Stoff
2. Komplexitaet durch simple Aussagen
3. Algorithmus entwerfen (maxteilsum), Komplexitaet bestimmen durch Iterations-, Rekursionsgleichung, Mastermethode
4. Sortieralogrithmen anders gestalten: InsertionSort, BubbleSort, SelectionSort, QuickSort, HeapSort, MergeSort
5. Algorithmus entwerfen; Aussagen zu Heaps mathematisch zeigen; CountSort und MapSort anders gestalten
6. Binaeren Verketteten Suchbaum implementieren; Algorithmus: durch Preorder, inorder, postorder eingabe binary tree bauen; AVL-Baeume angeben, die entstehen bei gegebenen Eingabewerten und Loeschung; kreiren eines Algorithmus, der alle AVL-Baeume der minimalen Hoehe h erstellt
7. RS-Baum konstruieren; in B-tree von Hoehe 5 gegebene WErte inorder einfuegen; die werte in umgekehreter Reihenfolge entfernen
8. bei gegebener Hash-Gleichung Positionen von gg Zahlen ermitteln; hash table mit open addressing erklaeren und implementieren mit versch. ansaetzen; SkipListen implementieren
9. Textsuche mit NaiveSearch und BayerMoore; NaiveSearch Laufzeit beweisen; Adjazenzmatrix eines Graphen erklaeren
10. Adjazenzmatrix ist gegeben, ist G ungerichtet od gerichtet? BFS und DFS implementieren; Demonstration von Kruskal und Prim; priority queue implementieren
11. Algorithmus zur Erkennung von Zyklen in gerichteten Graphen;
Topologische Sortierung eines gerichteten azyklischen Graphen (DAG) in O(|V| + |E|), Umgang mit Zyklen; Durchführung von Dijkstra- und Bellman-Ford-Algorithmen, Zwischenschritte und Kantenreihenfolge; Durchführung von APSP- und FasterAPSP-Algorithmen, Matrizen nach Iterationen.
12. Algorithmus zur Berechnung kürzester Wege in einem DAG in Θ(|V| + |E|) mithilfe topologischer Sortierung; Demonstration des Floyd-Warshall-Algorithmus mit Distanz- und Vorgängermatrix sowie Implementierung in C/C++/Java/C#/Python; Konstruktion eines Graphen für spezifische Werteänderungen in der Vorgängermatrix des Floyd-Warshall-Algorithmus; Algorithmen für das Rucksackproblem (anteilig und ganzzahlig), effiziente Lösung für Variante 1 und Analyse der Schwächen bei Variante 2.
13. Reduktion von HK auf TSP, Bedingungen für NP-Vollständigkeit von TSP und Zugehörigkeit von HK zu P; Analyse von 2-PART und 3-PART (Eingabe und Ausgabe), Nachweis von 3-PART ∈ NP und Reduktion von 2-PART auf 3-PART; Durchführung eines Approximationsalgorithmus für ∆-TSP mit Zwischenschritten und Bestimmung der relativen Güte. 
